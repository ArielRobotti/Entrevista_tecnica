Retomando la idea de iterar en cada cuadrícula del tablero y comprobar el color de las casillas adyacentes, se implementó lo siguiente:
	Se crea un matriz de booleanos con igual forma que la matriz del tablero. Esta matriz se inicializa en False para todas las posiciones, y el estado de cada posición va a cambiar a True cuando esa posición sea iterada o cuando al ser visitada desde otra posición, el color coincida con el de la posición desde la que se la visitó.
		Ejemplo: AOBBU. Si la iteración principal está en la posición (0,2) es decir la primera B, esa posición en la matriz de booleanos cambiará a True y al visitar a los adyacentes es decir (0,1) y (0,3) la posición (0,3) de la matriz de booleanos también cambiará a True ya que es del mismo color que (0,2).
	Con esto se evita que luego, cuando la iteración principal recupere el control, se itere en alguna posición que ya fué visitada y contabilizada en alguna mancha.
	Esto no evita, sin embargo, que haya posiciones que se visitan varias veces (fué lo que me motivó en un principio a intentar otra solución). 
		Ejemplo: en [ ABBD,
					  EFBH,
					  IBBL]
		la posición (1,1) es consultada un total de 5 veces. Primero desde (0,1), luego desde (1,2),luego desde (2,1), luego desde (1,0) y finalmente desde la iteración principal, momento en el cual ya queda marcada como True en la matriz de booleanos y por lo tanto no se vuelve a consultar.
	La función get_big_stain es la que se encarga de iterar sobre las posiciones del tablero y al verificar que la posición actual no está marcada como True, envía la posición a la función scan() la cual se encarga de crear una lista, en principio, solo con la posición recibida como parámetro. Esta lista se envía a la función visit_neighbors() y allí se consulta a las casillas adyacentes a cada elemento de esa lista devolviendo luego otra lista con los adyacentes del mismo color. El tamaño de esta lista incrementará la variable size, que fue inicializada en 1, y es enviada nuevamente a la función visit_neighbors() mientras dicha función siga retornando una lista no vacía. Cuando la función antes mencionada devuelva una lista vacía se dejará de reenviar, la variable size dejará de incrementarse y la función scan() devolverá la variable size, que corresponderá al tamaño de la mancha que se detectó. Luego se evalua si ese valor es mayor que la mancha mas grande encontrada hasta el momento (variable big_stain[1]) y si es asi, se asignará a big_stain los nuevos valores: variable color y variable size en forma de tupla ej:('R',4) siendo 4 el valor devuelto por scan() y 'R' el valor de color, es decir, el valor de la matriz tab en la posicion place con el que se llamó a la función scan.
	Finalmente, tras completarse la iteración principal, la función get_big_stain devolverá la variable big_stain.
Como posible reducción de tiempos de ejecución en términos absolutos probaré iterando ya no sobre todos los elementos de la matriz sino de manera intercalada. En principio (fila par, columna par) y (fila impar columna impar). *Edit. Se observa una leve mejora
 
