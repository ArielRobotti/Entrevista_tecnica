La soluciòn implementada consiste en comparar los dos digitos "externos", por ejemplo en una lectura de 12:34 los digitos 1 y 4, y comparar los dos digitos "internos", es decir los digitos 2 y 3 según el mismo ejemplo. Para llevar a cabo la comparación se fragmenta cada digito en las lineas verticales y lineas horizontales que lo forman. Asumiendo que al girar el reloj para verlo en el espejo, esta rotación se hará sobre el eje "y", es decir, la parte de arriba del reloj seguirá estando arriba, las lineas horizontales se verán en el mismo lugar, y las lineas verticales estarán 'invertidas', ya que al girar el reloj sobre el eje "y" el lado derecho del reloj quedó ahora a nuestra izquierda. Por este motivo se comparan los digitos externos entre si y los internos tambien entre si. Y esta comparación consiste en que los segmentos verticales derechos de un digito tienen estar en el mismo estado (on/off) que los segmentos verticales izquierdos del otro digito y viceversa. Ademas, ambos digitos tienen que tener la misma configuracion (on/off) de segmentos horizontales.
Se optó por el uso de un diccionario con los digitos del 0 al 9 como claves y y a su vez cada clave es un diccionario cuyas claves son los segmentos verticales y los horizontales. El valor correspondiente a la clave de los segmentos horizontales será una lista de 3 booleanos que representan el estado de los segmentos horizontales corresponden al digito, y el valor correspondiente a la clave de los segmentos verticales será otro diccionario con el que se definira el estado de los segmentos izquierdos por un lado y el de los derechos por otro... wuuuu.
Para accerder a los segmentos derechos del número 9 por ejemplo simplemente se tendrá que hacer SEVEN_SEGMENTS['9']['vert']['l']